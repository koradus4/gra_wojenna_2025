from gui.ekran_startowy import EkranStartowy
from core.tura import TurnManager
from engine.player import Player
from gui.panel_generala import PanelGenerala
from gui.panel_dowodcy import PanelDowodcy
from core.ekonomia import EconomySystem
from engine.engine import GameEngine, update_all_players_visibility, clear_temp_visibility
from gui.panel_gracza import PanelGracza
from core.zwyciestwo import VictoryConditions
import tkinter as tk

# AI GENERA≈Å IMPORT
from ai import AIGeneral, is_ai_general, set_ai_general_enabled




def main():
    """G≈Ç√≥wna funkcja gry"""
    try:
        # Ekran startowy
        root = tk.Tk()
        ekran_startowy = EkranStartowy(root)
        root.mainloop()

        # Sprawd≈∫ czy u≈ºytkownik wybra≈Ç dane gry
        try:
            game_data = ekran_startowy.get_game_data()
            miejsca = game_data["miejsca"]
            czasy = game_data["czasy"]
            use_ai_general = game_data.get("use_ai_general", False)  # Odczytanie opcji AI
            
            # Ustawienie konfiguracji AI na podstawie wyboru u≈ºytkownika
            set_ai_general_enabled(use_ai_general)
        except AttributeError:
            print("‚ùå Nie wybrano danych gry - ko≈Ñczƒô")
            return

        # Inicjalizacja silnika gry (GameEngine jako ≈∫r√≥d≈Ço prawdy)
        game_engine = GameEngine(
            map_path="data/map_data.json",
            tokens_index_path="assets/tokens/index.json",
            tokens_start_path="assets/start_tokens.json",
            seed=42,
            read_only=True  # Zapobiega nadpisywaniu pliku mapy
        )

        # Tworzenie obiekt√≥w graczy z uwzglƒôdnieniem czasu na turƒô i ≈õcie≈ºek do zdjƒôƒá
        # Automatyczne przypisanie id dow√≥dc√≥w zgodnie z ownerami ≈ºeton√≥w
        # Polska: dow√≥dcy id=2,3; Niemcy: dow√≥dcy id=5,6
        # Ustal kolejno≈õƒá graczy na podstawie miejsc i r√≥l, aby pierwszym by≈Ç genera≈Ç wybranej nacji
        # Szukamy indeks√≥w dla ka≈ºdej roli i nacji
        polska_gen = miejsca.index("Polska")
        polska_dow1 = miejsca.index("Polska", polska_gen+1)
        polska_dow2 = miejsca.index("Polska", polska_dow1+1)
        niemcy_gen = miejsca.index("Niemcy")
        niemcy_dow1 = miejsca.index("Niemcy", niemcy_gen+1)
        niemcy_dow2 = miejsca.index("Niemcy", niemcy_dow1+1)

        # Kolejno≈õƒá: najpierw genera≈Ç tej nacji, kt√≥ra jest pierwsza w miejscach
        if niemcy_gen < polska_gen:
            players = [
                Player(4, "Niemcy", "Genera≈Ç", czasy[niemcy_gen], "c:/Users/klif/kampania1939_fixed/gui/images/Genera≈Ç pu≈Çkownik Walther von Brauchitsch.png"),
                Player(5, "Niemcy", "Dow√≥dca", czasy[niemcy_dow1], "c:/Users/klif/kampania1939_fixed/gui/images/Genera≈Ç Fedor von Bock.png"),
                Player(6, "Niemcy", "Dow√≥dca", czasy[niemcy_dow2], "c:/Users/klif/kampania1939_fixed/gui/images/Genera≈Ç Walther von Reichenau.png"),
                Player(1, "Polska", "Genera≈Ç", czasy[polska_gen], "c:/Users/klif/kampania1939_fixed/gui/images/Marsza≈Çek Polski Edward Rydz-≈ömig≈Çy.png"),
                Player(2, "Polska", "Dow√≥dca", czasy[polska_dow1], "c:/Users/klif/kampania1939_fixed/gui/images/Genera≈Ç Juliusz R√≥mmel.png"),
                Player(3, "Polska", "Dow√≥dca", czasy[polska_dow2], "c:/Users/klif/kampania1939_fixed/gui/images/Genera≈Ç Tadeusz Kutrzeba.png"),
            ]
        else:
            players = [
                Player(1, "Polska", "Genera≈Ç", czasy[polska_gen], "c:/Users/klif/kampania1939_fixed/gui/images/Marsza≈Çek Polski Edward Rydz-≈ömig≈Çy.png"),
                Player(2, "Polska", "Dow√≥dca", czasy[polska_dow1], "c:/Users/klif/kampania1939_fixed/gui/images/Genera≈Ç Juliusz R√≥mmel.png"),
                Player(3, "Polska", "Dow√≥dca", czasy[polska_dow2], "c:/Users/klif/kampania1939_fixed/gui/images/Genera≈Ç Tadeusz Kutrzeba.png"),
                Player(4, "Niemcy", "Genera≈Ç", czasy[niemcy_gen], "c:/Users/klif/kampania1939_fixed/gui/images/Genera≈Ç pu≈Çkownik Walther von Brauchitsch.png"),
                Player(5, "Niemcy", "Dow√≥dca", czasy[niemcy_dow1], "c:/Users/klif/kampania1939_fixed/gui/images/Genera≈Ç Fedor von Bock.png"),
                Player(6, "Niemcy", "Dow√≥dca", czasy[niemcy_dow2], "c:/Users/klif/kampania1939_fixed/gui/images/Genera≈Ç Walther von Reichenau.png"),
            ]

        # Uzupe≈Çnij economy dla wszystkich graczy (Genera≈Ç i Dow√≥dca)
        from core.ekonomia import EconomySystem
        for p in players:
            if not hasattr(p, 'economy') or p.economy is None:
                p.economy = EconomySystem()

        # --- UDOSTƒòPNIJ LISTƒò GRACZY W GAME_ENGINE ---
        game_engine.players = players

        # --- AKTUALIZACJA WIDOCZNO≈öCI NA START ---
        update_all_players_visibility(players, game_engine.tokens, game_engine.board)
        
        # --- SYNCHRONIZACJA PUNKT√ìW EKONOMICZNYCH DOW√ìDC√ìW Z SYSTEMEM EKONOMII ---
        for p in players:
            if hasattr(p, 'punkty_ekonomiczne'):
                p.punkty_ekonomiczne = p.economy.get_points()['economic_points']
        
        # Inicjalizacja mened≈ºera tur
        turn_manager = TurnManager(players, game_engine=game_engine)
        
        # Uruchomienie gry Human vs Human (z mo≈ºliwo≈õciƒÖ AI Genera≈Ç√≥w)
        run_human_vs_human_game(game_engine, players, turn_manager)
        
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd w main(): {e}")
        import traceback
        traceback.print_exc()

def run_human_vs_human_game(game_engine, players, turn_manager):
    """Uruchomienie gry w trybie Human vs Human (z mo≈ºliwo≈õciƒÖ AI Genera≈Ç√≥w)"""
    print("üéÆ Uruchamianie gry Human vs Human...")
    print(f"   Utworzono {len(players)} graczy:")
    for p in players:
        ai_status = " [AI]" if is_ai_general(p) else ""
        print(f"   - {p.name} ({p.nation}, {p.role}){ai_status}")
    
    # --- WARUNKI ZWYCIƒòSTWA: 30 rund ---
    victory_conditions = VictoryConditions(max_turns=30)
    just_loaded_save = False  # Flaga: czy w≈Ça≈õnie wczytano save
    last_loaded_player_info = None  # Przechowuj info o aktywnym graczu po wczytaniu save
    
    # Pƒôtla tur - u≈ºywamy logiki z main_alternative.py
    while True:
        # Je≈õli po wczytaniu save jest info o aktywnym graczu, prze≈ÇƒÖcz na niego
        if last_loaded_player_info:
            found = None
            for p in players:
                if (str(p.id) == str(last_loaded_player_info.get('id')) and
                    p.role == last_loaded_player_info.get('role') and
                    p.nation == last_loaded_player_info.get('nation')):
                    found = p
                    break
            if found:
                current_player = found
                turn_manager.current_player_index = players.index(found)
            last_loaded_player_info = None
        else:
            current_player = turn_manager.get_current_player()
            
        update_all_players_visibility(players, game_engine.tokens, game_engine.board)
        
        print(f"\nüèÜ TURA {turn_manager.current_turn}: {current_player.name} ({current_player.nation}, {current_player.role})")
        
        # Tworzenie paneli z pe≈ÇnƒÖ funkcjonalno≈õciƒÖ
        if current_player.role == "Genera≈Ç":
            # SPRAWD≈π CZY TO AI GENERA≈Å
            if is_ai_general(current_player):
                # AI GENERA≈Å - bez GUI, automatyczne decyzje
                ai_general = AIGeneral(current_player, game_engine, players)
                
                # Generowanie punkt√≥w ekonomicznych (jak w normalnym panelu)
                start_points = current_player.economy.economic_points
                current_player.economy.generate_economic_points()
                current_player.economy.add_special_points()
                available_points = current_player.economy.get_points()['economic_points']
                
                print(f"  üí∞ Generowanie ekonomii: {start_points} ‚Üí {available_points} punkt√≥w")
                
                # AI podejmuje wszystkie decyzje automatycznie
                ai_general.make_turn_decisions()
                
                # POMI≈É app.mainloop() - AI nie potrzebuje GUI
                app = None  # ≈ªeby nie by≈Ço b≈Çƒôd√≥w w dalszym kodzie
            else:
                # CZ≈ÅOWIEK - normalny panel graficzny
                app = PanelGenerala(turn_number=turn_manager.current_turn, ekonomia=current_player.economy, gracz=current_player, gracze=players, game_engine=game_engine)
        elif current_player.role == "Dow√≥dca":
            app = PanelDowodcy(turn_number=turn_manager.current_turn, remaining_time=current_player.time_limit * 60, gracz=current_player, game_engine=game_engine)
        
        # Patch dla save/load funkcjonalno≈õci - tylko dla paneli graficznych
        if app is not None:
            def patch_on_load(panel_gracza):
                def new_on_load():
                    import os
                    from tkinter import filedialog, messagebox
                    saves_dir = os.path.join(os.getcwd(), 'saves')
                    os.makedirs(saves_dir, exist_ok=True)
                    path = filedialog.askopenfilename(
                        filetypes=[('Plik zapisu', '*.json')],
                        initialdir=saves_dir
                    )
                    if path:
                        try:
                            from engine.save_manager import load_game
                            nonlocal last_loaded_player_info, just_loaded_save
                            last_loaded_player_info = load_game(path, game_engine)
                            just_loaded_save = True
                            if hasattr(panel_gracza.master, 'panel_mapa'):
                                panel_gracza.master.panel_mapa.refresh()
                            if last_loaded_player_info:
                                msg = f"Gra zosta≈Ça wczytana!\nAktywny gracz: {last_loaded_player_info.get('role','?')} {last_loaded_player_info.get('id','?')} ({last_loaded_player_info.get('nation','?')})"
                                messagebox.showinfo("Wczytanie gry", msg)
                            else:
                                messagebox.showinfo("Wczytanie gry", "Gra zosta≈Ça wczytana!")
                            panel_gracza.winfo_toplevel().destroy()  # Zamknij ca≈Çe okno, nie tylko ramkƒô
                        except Exception as e:
                            messagebox.showerror("B≈ÇƒÖd wczytywania", str(e))
                panel_gracza.on_load = new_on_load
                if hasattr(panel_gracza, 'btn_load'):
                    panel_gracza.btn_load.config(command=panel_gracza.on_load)

            # Znajd≈∫ i zaaplikuj patch dla save/load - tylko dla paneli graficznych
            if hasattr(app, 'left_frame'):
                for child in app.left_frame.winfo_children():
                    if isinstance(child, PanelGracza):
                        patch_on_load(child)

        # --- USTAW AKTUALNEGO GRACZA W SILNIKU (DLA PANEL_MAPA) ---
        game_engine.current_player_obj = current_player

        # Aktualizacja pogody dla panelu - tylko dla paneli graficznych
        if app is not None and hasattr(app, 'update_weather'):
            app.update_weather(turn_manager.current_weather)
            
        # Aktualizacja punkt√≥w ekonomicznych dla paneli genera≈Ç√≥w - tylko dla paneli graficznych
        if app is not None and isinstance(app, PanelGenerala):
            # Generowanie punkt√≥w ekonomicznych
            start_points = current_player.economy.economic_points
            current_player.economy.generate_economic_points()
            current_player.economy.add_special_points()
            available_points = current_player.economy.get_points()['economic_points']
            app.update_economy(available_points)  # Przekazanie dostƒôpnych punkt√≥w ekonomicznych

            # Synchronizacja dostƒôpnych punkt√≥w w sekcji suwak√≥w
            app.zarzadzanie_punktami(available_points)

        # Aktualizacja punkt√≥w ekonomicznych dla paneli dow√≥dc√≥w - tylko dla paneli graficznych
        if app is not None and isinstance(app, PanelDowodcy):
            przydzielone_punkty = current_player.economy.get_points()['economic_points']
            app.update_economy(przydzielone_punkty)  # Aktualizacja interfejsu dow√≥dcy
            # --- Synchronizacja punkt√≥w ekonomicznych dow√≥dcy z systemem ekonomii ---
            current_player.punkty_ekonomiczne = przydzielone_punkty

        # Uruchomienie panelu graficznego - tylko dla ludzi
        if app is not None:
            try:
                app.mainloop()  # Uruchomienie panelu
            except Exception as e:
                print(f"B≈ÇƒÖd panelu: {e}")

        # Przej≈õcie do kolejnego gracza i zwr√≥cenie informacji czy zako≈Ñczy≈Ça siƒô pe≈Çna tura
        is_full_turn_end = turn_manager.next_turn()
        
        # --- ROZDZIEL PUNKTY Z KEY_POINTS tylko na koniec pe≈Çnej tury ---
        if is_full_turn_end:
            game_engine.process_key_points(players)  # Ignoruj zwracanƒÖ warto≈õƒá
            
        # --- AKTUALIZUJ WIDOCZNO≈öƒÜ NA KO≈ÉCU KA≈ªDEJ TURY ---
        game_engine.update_all_players_visibility(players)
            
        # --- SPRAWDZENIE KO≈ÉCA GRY ---
        if victory_conditions.check_game_over(turn_manager.current_turn):
            print(victory_conditions.get_victory_message())
            print("=== PODSUMOWANIE ===")
            for p in players:
                vp = getattr(p, "victory_points", 0)
                print(f"{p.nation} {p.role} (id={p.id}): {vp} punkt√≥w zwyciƒôstwa")
            print("====================")
            break
            
        # Reset blokady trybu ruchu na poczƒÖtku ka≈ºdej tury, ale NIE po wczytaniu save
        if not just_loaded_save:
            for t in game_engine.tokens:
                t.movement_mode_locked = False
                
        # --- DODANE: wymuszenie aktualnej referencji gracza po wczytaniu save ---
        if just_loaded_save:
            # Po wczytaniu save'a zsynchronizuj listƒô players i current_player z game_engine
            players = game_engine.players
            clear_temp_visibility(game_engine.players)
            update_all_players_visibility(game_engine.players, game_engine.tokens, game_engine.board)
            # Znajd≈∫ aktualnego gracza po wczytaniu save
            found = None
            for p in game_engine.players:
                if (str(p.id) == str(last_loaded_player_info.get('id')) and
                    p.role == last_loaded_player_info.get('role') and
                    p.nation == last_loaded_player_info.get('nation')):
                    found = p
                    break
            if found:
                game_engine.current_player_obj = found
                current_player = found
        just_loaded_save = False
        clear_temp_visibility(players)

if __name__ == "__main__":
    main()